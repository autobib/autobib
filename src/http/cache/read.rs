use std::{collections::HashMap, fs::File};

use bincode::config;
use ureq::{Body, http::Uri};

use super::{ResponseBytes, response_cache_file};
use crate::http::Client;

/// A client which intercepts a request and replaces it with a deserialized response from a dictionary
/// read from the `responses.dat` file. This file should have been generated by
/// `LocalWriteClient`.
pub struct LocalReadClient {
    lookup: HashMap<String, ResponseBytes>,
}

impl LocalReadClient {
    pub fn new() -> Self {
        let data_file = response_cache_file();
        let mut lookup_file = File::open(&data_file).unwrap_or_else(|_| {
            panic!(
                "Failed to open response data file '{}'!",
                data_file.display()
            )
        });

        let lookup = bincode::decode_from_std_read(&mut lookup_file, config::standard())
            .expect("Failed to decide binary contents of data file");

        Self { lookup }
    }
}

impl Client for LocalReadClient {
    type Body = Body;

    fn get<T>(&self, uri: T) -> Result<ureq::http::Response<Body>, ureq::Error>
    where
        Uri: TryFrom<T>,
        <Uri as TryFrom<T>>::Error: Into<ureq::http::Error>,
    {
        let uri = Uri::try_from(uri).map_err(Into::<ureq::http::Error>::into)?;
        let response_bytes = self.lookup.get(&uri.to_string()).ok_or(ureq::Error::Other(
            format!("Url '{uri}' does not exist in local response cache").into(),
        ))?;
        response_bytes.try_into()
    }
}
