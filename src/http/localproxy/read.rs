use std::{collections::HashMap, fs::File};

use bincode::config;
use ureq::{Body, http::Uri};

use super::{LOCALPROXY_DATA_FILE, ResponseBytes};
use crate::http::Client;

/// A client which intercepts a request and replaces it with a deserialized response from a dictionary
/// read from the `localproxy.dat` file. This file should have been generated by
/// `LocalWriteClient`.
pub struct LocalReadClient {
    lookup: HashMap<String, ResponseBytes>,
}

impl LocalReadClient {
    pub fn new() -> Self {
        let mut lookup_file = File::open(LOCALPROXY_DATA_FILE).expect(&format!(
            "Failed to open proxy data file '{}'!",
            LOCALPROXY_DATA_FILE
        ));

        let lookup = bincode::decode_from_std_read(&mut lookup_file, config::standard())
            .expect("Failed to decide binary contents of data file 'localproxy.dat'!");

        Self { lookup }
    }
}

impl Client for LocalReadClient {
    type Body = Body;

    fn get<T>(&self, uri: T) -> Result<ureq::http::Response<Body>, crate::error::ProviderError>
    where
        Uri: TryFrom<T>,
        <Uri as TryFrom<T>>::Error: Into<ureq::http::Error>,
    {
        let uri = Uri::try_from(uri).map_err(Into::<ureq::http::Error>::into)?;
        let response_bytes = self.lookup.get(&uri.to_string()).ok_or(ureq::Error::Other(
            format!("Url '{}' does not exist in local proxy dictionary", uri).into(),
        ))?;
        response_bytes.try_into().map_err(Into::into)
    }
}
